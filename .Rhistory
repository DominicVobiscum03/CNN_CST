yp_count
yp_count <- integer(10000)
yp_count
count <- 0
#yptest <- matrix(0, nxd, nphi)
yp_count <- integer(10000)
bin_count <- integer(10000)
count <- 0
make_torch_system_matrix <- function(nxd, nrd, nphi) {
system_matrix <- torch_zeros(nrd*nphi, nxd*nxd);
for (xv in 1:nxd) {
for (yv in 1:nxd){
for (ph in 1:nphi){
yp <- -(xv-(nxd*0.5)) * sin(ph*pi/nphi)+(yv-(nxd*0.5)) * cos(ph*pi/nphi);
count <- count+1;
yp_count[count] <- yp;
yp_bin <- as.integer(yp+nrd/2);
bin_count[count]<- yp_bin
system_matrix[yp_bin + ph*nrd, xv + yv*nxd] = 1;
}
}
return(system_matrix);
return(yp_count);
return(bin_count)
}
#yptest <- matrix(0, nxd, nphi)
yp_count <- integer(10000)
bin_count <- integer(10000)
count <- 0
make_torch_system_matrix <- function(nxd, nrd, nphi) {
system_matrix <- torch_zeros(nrd*nphi, nxd*nxd);
for (xv in 1:nxd) {
for (yv in 1:nxd){
for (ph in 1:nphi){
yp <- -(xv-(nxd*0.5)) * sin(ph*pi/nphi)+(yv-(nxd*0.5)) * cos(ph*pi/nphi);
count <- count+1;
yp_count[count] <- yp;
yp_bin <- as.integer(yp+nrd/2);
bin_count[count]<- yp_bin
system_matrix[yp_bin + ph*nrd, xv + yv*nxd] = 1;
}
}
return(system_matrix);
return(yp_count);
return(bin_count);
}
#yptest <- matrix(0, nxd, nphi)
yp_count <- integer(10000)
bin_count <- integer(10000)
count <- 0
make_torch_system_matrix <- function(nxd, nrd, nphi) {
system_matrix <- torch_zeros(nrd*nphi, nxd*nxd);
for (xv in 1:nxd) {
for (yv in 1:nxd){
for (ph in 1:nphi){
yp <- -(xv-(nxd*0.5)) * sin(ph*pi/nphi)+(yv-(nxd*0.5)) * cos(ph*pi/nphi);
count <- count+1;
yp_count[count] <- yp;
yp_bin <- as.integer(yp+nrd/2);
bin_count[count]<- yp_bin;
system_matrix[yp_bin + ph*nrd, xv + yv*nxd] = 1;
}
}
return(system_matrix);
return(yp_count);
return(bin_count);
}
#yptest <- matrix(0, nxd, nphi)
yp_count <- integer(10000)
bin_count <- integer(10000)
count <- 0
make_torch_system_matrix <- function(nxd, nrd, nphi) {
system_matrix <- torch_zeros(nrd*nphi, nxd*nxd);
for (xv in 1:nxd) {
for (yv in 1:nxd){
for (ph in 1:nphi){
yp <- -(xv-(nxd*0.5)) * sin(ph*pi/nphi)+(yv-(nxd*0.5)) * cos(ph*pi/nphi);
count <- count+1;
yp_count[count] <- yp;
yp_bin <- as.integer(yp+nrd/2);
bin_count[count]<- yp_bin;
system_matrix[yp_bin + ph*nrd, xv + yv*nxd] = 1;
}
}
return(system_matrix, yp_count, bin_count);
}
#yptest <- matrix(0, nxd, nphi)
yp_count <- integer(10000)
bin_count <- integer(10000)
count <- 0
make_torch_system_matrix <- function(nxd, nrd, nphi) {
system_matrix <- torch_zeros(nrd*nphi, nxd*nxd);
for (xv in 1:nxd) {
for (yv in 1:nxd){
for (ph in 1:nphi){
yp <- -(xv-(nxd*0.5)) * sin(ph*pi/nphi)+(yv-(nxd*0.5)) * cos(ph*pi/nphi);
count <- count+1;
yp_count[count] <- yp;
yp_bin <- as.integer(yp+nrd/2);
bin_count[count]<- yp_bin;
system_matrix[yp_bin + ph*nrd, xv + yv*nxd] = 1;
}
}
}
return(c(system_matrix, yp_count, bin_count));
}
t <- make_torch_system_matrix(nxd, nrd, nphi)
yp_count
#yptest <- matrix(0, nxd, nphi)
yp_count <- integer(10000)
bin_count <- integer(10000)
count <- 0
make_torch_system_matrix <- function(nxd, nrd, nphi) {
system_matrix <- torch_zeros(nrd*nphi, nxd*nxd);
for (xv in 1:nxd) {
for (yv in 1:nxd){
for (ph in 1:nphi){
yp <- -(xv-(nxd*0.5)) * sin(ph*pi/nphi)+(yv-(nxd*0.5)) * cos(ph*pi/nphi);
count <- count+1;
yp_count[count] <- yp;
yp_bin <- as.integer(yp+nrd/2);
bin_count[count]<- yp_bin;
system_matrix[yp_bin + ph*nrd, xv + yv*nxd] = 1;
}
}
}
return(system_matrix, yp_count, bin_count);
}
t <- make_torch_system_matrix(nxd, nrd, nphi)
yp_count
t <- torch_zeros(nrd*nphi, nxd*nxd)
t
s <- fp_system_torch(reftorch, t, nxd, nrd, nphi)
sino <- s$squeeze(1)
sino<- sino$squeeze(1)
true_sinogram_torch <- s
sino <- sino %>% as.matrix()
image(sino)
sino
#yptest <- matrix(0, nxd, nphi)
#yp_count <- integer(10000)
#bin_count <- integer(10000)
#count <- 0
#make_torch_system_matrix <- function(nxd, nrd, nphi) {
#system_matrix <- torch_zeros(nrd*nphi, nxd*nxd);
#for (xv in 1:nxd) {
#for (yv in 1:nxd){
#for (ph in 1:nphi){
# yp <- -(xv-(nxd*0.5)) * sin(ph*pi/nphi)+(yv-(nxd*0.5)) * cos(ph*pi/nphi);
# count <- count+1;
# yp_count[count] <- yp;
# yp_bin <- as.integer(yp+nrd/2);
# bin_count[count]<- yp_bin;
# system_matrix[yp_bin + ph*nrd, xv + yv*nxd] = 1;
# }
# }
# }
#return(system_matrix, yp_count, bin_count);
# }
make_torch_system_matrix <- function(nxd, nrd, nphi) {
system_matrix <- torch$zeros(nrd * nphi, nxd * nxd)
for (xv in 1:nxd) {
for (yv in 1:nxd) {
for (ph in 1:nphi) {
yp <- -(xv - (nxd * 0.5)) * sin(ph * pi / nphi) + (yv - (nxd * 0.5)) * cos(ph * pi / nphi)
yp_bin <- as.integer(yp + nrd / 2)
system_matrix[[yp_bin + ph * nrd, xv + yv * nxd]] <- 1.0
}
}
}
return(system_matrix)
}
t <- make_torch_system_matrix(nxd, nrd, nphi)
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = normalizePath(".."))
library(torch)
library(luz)
library(tidymodels)
library(broom)
library(raster)
library(png)
nxd <- 64
disp_scale <- 5
nrd <- ceiling(nxd * 1.42)
nphi <- nrd
ref65 <- read.csv("raw_data/65ref.csv")
ref65 <- ref65 %>% as.data.frame()
ref65 <- ref65 %>% as.matrix()
ref65 <- ref65[2:65,2:65]
refimg <- ref65 %>% image()
reftorch <- torch_tensor(ref65)$unsqueeze(1)
reftorch <- reftorch$unsqueeze(1)
reftorch <- reftorch$float()
#yptest <- matrix(0, nxd, nphi)
#yp_count <- integer(10000)
#bin_count <- integer(10000)
#count <- 0
#make_torch_system_matrix <- function(nxd, nrd, nphi) {
#system_matrix <- torch_zeros(nrd*nphi, nxd*nxd);
#for (xv in 1:nxd) {
#for (yv in 1:nxd){
#for (ph in 1:nphi){
# yp <- -(xv-(nxd*0.5)) * sin(ph*pi/nphi)+(yv-(nxd*0.5)) * cos(ph*pi/nphi);
# count <- count+1;
# yp_count[count] <- yp;
# yp_bin <- as.integer(yp+nrd/2);
# bin_count[count]<- yp_bin;
# system_matrix[yp_bin + ph*nrd, xv + yv*nxd] = 1;
# }
# }
# }
#return(system_matrix, yp_count, bin_count);
# }
make_torch_system_matrix <- function(nxd, nrd, nphi) {
system_matrix <- torch$zeros(nrd * nphi, nxd * nxd)
for (xv in 1:nxd) {
for (yv in 1:nxd) {
for (ph in 1:nphi) {
yp <- -(xv - (nxd * 0.5)) * sin(ph * pi / nphi) + (yv - (nxd * 0.5)) * cos(ph * pi / nphi)
yp_bin <- as.integer(yp + nrd / 2)
system_matrix[[yp_bin + ph * nrd, xv + yv * nxd]] <- 1.0
}
}
}
return(system_matrix)
}
fp_system_torch <- function(image, sys_mat, nxd, nrd, nphi) {
fp <- torch_reshape(image, c(nxd*nxd,1));
fb <- torch_mm(sys_mat, fp);
return(torch_reshape(fb, c(nphi,nrd)));
}
bp_system_torch <- function(sino, sys_mat, nxd, nrd, nphi) {
return(torch_reshape(torch_mm(sys_mat.T, torch_reshape(sino, c(nrd*nphi,1))), c(nxd,nxd)))
}
t <- make_torch_system_matrix(nxd, nrd, nphi)
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = normalizePath(".."))
library(torch)
library(luz)
library(tidymodels)
library(broom)
library(raster)
library(png)
nxd <- 64
disp_scale <- 5
nrd <- ceiling(nxd * 1.42)
nphi <- nrd
ref65 <- read.csv("raw_data/65ref.csv")
ref65 <- ref65 %>% as.data.frame()
ref65 <- ref65 %>% as.matrix()
ref65 <- ref65[2:65,2:65]
refimg <- ref65 %>% image()
reftorch <- torch_tensor(ref65)$unsqueeze(1)
reftorch <- reftorch$unsqueeze(1)
reftorch <- reftorch$float()
#yptest <- matrix(0, nxd, nphi)
#yp_count <- integer(10000)
#bin_count <- integer(10000)
#count <- 0
#make_torch_system_matrix <- function(nxd, nrd, nphi) {
#system_matrix <- torch_zeros(nrd*nphi, nxd*nxd);
#for (xv in 1:nxd) {
#for (yv in 1:nxd){
#for (ph in 1:nphi){
# yp <- -(xv-(nxd*0.5)) * sin(ph*pi/nphi)+(yv-(nxd*0.5)) * cos(ph*pi/nphi);
# count <- count+1;
# yp_count[count] <- yp;
# yp_bin <- as.integer(yp+nrd/2);
# bin_count[count]<- yp_bin;
# system_matrix[yp_bin + ph*nrd, xv + yv*nxd] = 1;
# }
# }
# }
#return(system_matrix, yp_count, bin_count);
# }
make_torch_system_matrix <- function(nxd, nrd, nphi) {
system_matrix <- torch$zeros(nrd * nphi, nxd * nxd)
for (xv in 1:nxd) {
for (yv in 1:nxd) {
for (ph in 1:nphi) {
yp <- -(xv - (nxd * 0.5)) * sin(ph * pi / nphi) + (yv - (nxd * 0.5)) * cos(ph * pi / nphi)
yp_bin <- as.integer(yp + nrd / 2)
system_matrix[[yp_bin + ph * nrd, xv + yv * nxd]] <- 1.0
}
}
}
return(system_matrix)
}
fp_system_torch <- function(image, sys_mat, nxd, nrd, nphi) {
fp <- torch_reshape(image, c(nxd*nxd,1));
fb <- torch_mm(sys_mat, fp);
return(torch_reshape(fb, c(nphi,nrd)));
}
bp_system_torch <- function(sino, sys_mat, nxd, nrd, nphi) {
return(torch_reshape(torch_mm(sys_mat.T, torch_reshape(sino, c(nrd*nphi,1))), c(nxd,nxd)))
}
t <- make_torch_system_matrix(nxd, nrd, nphi)
getwd()
read.csv("clean_data")
FBP <- read.csv("clean_data/FBP1.csv")
FBP
library(tidyverse)
FBP <- FBP %>% as.matrix()
FBP
dim(FBP)
FBP <- FBP[,2:66]
FBP %>% image()
FBP <- read.csv("clean_data/FBP2.csv")
library(tidyverse)
FBP <- FBP %>% as.matrix()
FBP <- FBP[,2:66]
FBP %>% image()
FBP2 <- read.csv("clean_data/FBP1.csv")
FBP2 <- FBP2 %>% as.matrix()
FBP2 <- FBP2[,2:66]
FBP3 <- FBP+FBP2
FBP3 %>% image()
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir=normalizePath(".."))
library(neuralnet)
library(tidyverse)
library(binhf)
library(Matrix)
library(ggplot2)
library(pracma)
library(OpenImageR)
# read in reference data
m <- read.csv("raw_data/65ref.csv")
# read in reference data
m <- read.csv("raw_data/65ref.csv")
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir=normalizePath(".."))
library(neuralnet)
library(tidyverse)
library(binhf)
library(Matrix)
library(ggplot2)
library(pracma)
library(OpenImageR)
# read in sinogram data
sino <- read.csv('raw_data/65sin.csv')
sino <- sino[, -c(1)]
# number of projections
nAngle  <- ncol(sino)
# number of detectors
nDetect <- nrow(sino)
# Degrees between projections
angleStep <- 180/(nAngle-1)
# compute angle of each projection in sinogram
degree <- data.frame(angle = seq(0,nAngle-1)*angleStep)
# initialize weights
nn <- list()
nn$weights <- list()
nn$weights[[1]] <- matrix(0, nrow = 16, ncol = 2)
nn$weights[[2]] <- matrix(0, nrow = 3, ncol = 1)
error <- matrix(nrow = 1, ncol = 0)
for (i in 1:length(output)){
# compute shift of sinogram detector positions for each projection based on current image pixel
degree$pixel <- round(x[i]*cos(pi*degree$angle/180) + z[i]*sin(pi*degree$angle/180))
# transpose the sinogram
tsino <- t(sino)
# create a space with dimension tsino
ssino <- tsino
######################################################## SHIFT SUM FLIP
# Perform shift according to dShift
for (j in 1:nAngle){
shift_amount <- degree$pixel[j]
shifted_row <- circshift(tsino[j, ], shift_amount)
ssino[j, ] <- shifted_row
}
# perform summation
f_vector <- colSums(ssino)
# perform flip
z_vector <- rev(f_vector)
################################################################## DATA
data <- t(as_tibble(c(z_vector, output[i])))
# Define names of the columns for the data to used by function
ANN_names <- c(paste0("z",(as.character(c(seq(1:nDetect))))),"o")
colnames(data) <- ANN_names
############################################################### FORMULA
f <- as.formula(paste(ANN_names[nDetect+1],
"~",
paste(ANN_names[!ANN_names %in% "o"], collapse = " + ")
)
)
############################################################ NEURAL NET
nn <-neuralnet(f, data, hidden = 2,
startweights = nn$weights,
algorithm = 'backprop',
learningrate = 0.0001)
error[i] <- nn$result.matrix[1]
}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir=normalizePath(".."))
library(neuralnet)
library(tidyverse)
library(binhf)
library(Matrix)
library(ggplot2)
library(pracma)
library(OpenImageR)
# read in reference data
m <- read.csv("raw_data/65ref.csv")
m <- m[, -c(1)]
v <- matrix(nrow = 3, ncol = 0)
# Populate 'v' with columns, rows, and values from 'm'
for (i in 1:nrow(m)){
for (j in 1:ncol(m)){
v <- cbind(v, c(i,j,m[i,j]))
}
}
# Create empty vectors `x`, `z`, and 'output'
x <- vector(length = 0)
z <- vector(length = 0)
output <- vector(length = 0)
# Extract values from each row of `v`
for (i in 1:ncol(v)){
x <- c(x, v[2, i])
z <- c(z, v[1, i])
output <- c(output, v[3, i])
}
x <- (x-(max(x)+1)/2) # make x and z correct for the shift flip sum code
z <- (z-(max(z)+1)/2) # origin referenced coordinates
# read in sinogram data
sino <- read.csv('raw_data/65sin.csv')
sino <- sino[, -c(1)]
# number of projections
nAngle  <- ncol(sino)
# number of detectors
nDetect <- nrow(sino)
# Degrees between projections
angleStep <- 180/(nAngle-1)
# compute angle of each projection in sinogram
degree <- data.frame(angle = seq(0,nAngle-1)*angleStep)
# initialize weights
nn <- list()
nn$weights <- list()
nn$weights[[1]] <- matrix(0, nrow = 16, ncol = 2)
nn$weights[[2]] <- matrix(0, nrow = 3, ncol = 1)
error <- matrix(nrow = 1, ncol = 0)
for (i in 1:length(output)){
# compute shift of sinogram detector positions for each projection based on current image pixel
degree$pixel <- round(x[i]*cos(pi*degree$angle/180) + z[i]*sin(pi*degree$angle/180))
# transpose the sinogram
tsino <- t(sino)
# create a space with dimension tsino
ssino <- tsino
######################################################## SHIFT SUM FLIP
# Perform shift according to dShift
for (j in 1:nAngle){
shift_amount <- degree$pixel[j]
shifted_row <- circshift(tsino[j, ], shift_amount)
ssino[j, ] <- shifted_row
}
# perform summation
f_vector <- colSums(ssino)
# perform flip
z_vector <- rev(f_vector)
################################################################## DATA
data <- t(as_tibble(c(z_vector, output[i])))
# Define names of the columns for the data to used by function
ANN_names <- c(paste0("z",(as.character(c(seq(1:nDetect))))),"o")
colnames(data) <- ANN_names
############################################################### FORMULA
f <- as.formula(paste(ANN_names[nDetect+1],
"~",
paste(ANN_names[!ANN_names %in% "o"], collapse = " + ")
)
)
############################################################ NEURAL NET
nn <-neuralnet(f, data, hidden = 2,
startweights = nn$weights)
error[i] <- nn$result.matrix[1]
}
plot(nn, rep = "best")
# Creating matrices 'm1' which contains the weights from the first layer and 'm2' which contains the
# weights from the second layer
m1 <- nn$weights[[1]][[1]]
m2 <- nn$weights[[1]][[2]]
m1 <- m1 %>% as.data.frame()
m2 <- m2 %>% as.data.frame()
filt_sinoA <- sino
filt_sinoB <- sino
number_cols <- ncol(sino)
for(val in 1:number_cols){
filt_sinoA[,val] <- convolve(sino[,val], m1[2:91,1], type ="circular")
}
filt_sinoA %>%
as.matrix()
write_csv(filt_sinoA, "raw_data/filtsinoa.csv")
for(val in 1:number_cols){
filt_sinoB[,val] <- convolve(sino[,val], m1[2:91,2], type ="circular")
}
#filt_sinoB %>%
as.matrix()
filt_sinoA <- sino
filt_sinoB <- sino
number_cols <- ncol(sino)
for(val in 1:number_cols){
filt_sinoA[,val] <- convolve(sino[,val], m1[2:91,1], type ="circular")
}
filt_sinoA %>%
as.matrix()
write_csv(filt_sinoA, "raw_data/filtsinoa.csv")
for(val in 1:number_cols){
filt_sinoB[,val] <- convolve(sino[,val], m1[2:91,2], type ="circular")
}
filt_sinoB %>%
as.matrix()
write_csv(filt_sinoB, "raw_data/filtsinob.csv")
write_csv(m1, "raw_data/m1.csv")
write_csv(m2, "raw_data/m2.csv")

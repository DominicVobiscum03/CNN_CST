# bin_count[count]<- yp_bin;
# system_matrix[yp_bin + ph*nrd, xv + yv*nxd] = 1;
# }
# }
# }
#return(system_matrix, yp_count, bin_count);
# }
make_torch_system_matrix <- function(nxd, nrd, nphi) {
system_matrix <- torch$zeros(nrd * nphi, nxd * nxd)
for (xv in 1:nxd) {
for (yv in 1:nxd) {
for (ph in 1:nphi) {
yp <- -(xv - (nxd * 0.5)) * sin(ph * pi / nphi) + (yv - (nxd * 0.5)) * cos(ph * pi / nphi)
yp_bin <- as.integer(yp + nrd / 2)
system_matrix[[yp_bin + ph * nrd, xv + yv * nxd]] <- 1.0
}
}
}
return(system_matrix)
}
fp_system_torch <- function(image, sys_mat, nxd, nrd, nphi) {
fp <- torch_reshape(image, c(nxd*nxd,1));
fb <- torch_mm(sys_mat, fp);
return(torch_reshape(fb, c(nphi,nrd)));
}
bp_system_torch <- function(sino, sys_mat, nxd, nrd, nphi) {
return(torch_reshape(torch_mm(sys_mat.T, torch_reshape(sino, c(nrd*nphi,1))), c(nxd,nxd)))
}
t <- make_torch_system_matrix(nxd, nrd, nphi)
getwd()
read.csv("clean_data")
FBP <- read.csv("clean_data/FBP1.csv")
FBP
library(tidyverse)
FBP <- FBP %>% as.matrix()
FBP
dim(FBP)
FBP <- FBP[,2:66]
FBP %>% image()
FBP <- read.csv("clean_data/FBP2.csv")
library(tidyverse)
FBP <- FBP %>% as.matrix()
FBP <- FBP[,2:66]
FBP %>% image()
FBP2 <- read.csv("clean_data/FBP1.csv")
FBP2 <- FBP2 %>% as.matrix()
FBP2 <- FBP2[,2:66]
FBP3 <- FBP+FBP2
FBP3 %>% image()
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir=normalizePath(".."))
library(neuralnet)
library(tidyverse)
library(binhf)
library(Matrix)
library(ggplot2)
library(pracma)
library(OpenImageR)
# read in reference data
m <- read.csv("raw_data/65ref.csv")
# read in reference data
m <- read.csv("raw_data/65ref.csv")
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir=normalizePath(".."))
library(neuralnet)
library(tidyverse)
library(binhf)
library(Matrix)
library(ggplot2)
library(pracma)
library(OpenImageR)
# read in sinogram data
sino <- read.csv('raw_data/65sin.csv')
sino <- sino[, -c(1)]
# number of projections
nAngle  <- ncol(sino)
# number of detectors
nDetect <- nrow(sino)
# Degrees between projections
angleStep <- 180/(nAngle-1)
# compute angle of each projection in sinogram
degree <- data.frame(angle = seq(0,nAngle-1)*angleStep)
# initialize weights
nn <- list()
nn$weights <- list()
nn$weights[[1]] <- matrix(0, nrow = 16, ncol = 2)
nn$weights[[2]] <- matrix(0, nrow = 3, ncol = 1)
error <- matrix(nrow = 1, ncol = 0)
for (i in 1:length(output)){
# compute shift of sinogram detector positions for each projection based on current image pixel
degree$pixel <- round(x[i]*cos(pi*degree$angle/180) + z[i]*sin(pi*degree$angle/180))
# transpose the sinogram
tsino <- t(sino)
# create a space with dimension tsino
ssino <- tsino
######################################################## SHIFT SUM FLIP
# Perform shift according to dShift
for (j in 1:nAngle){
shift_amount <- degree$pixel[j]
shifted_row <- circshift(tsino[j, ], shift_amount)
ssino[j, ] <- shifted_row
}
# perform summation
f_vector <- colSums(ssino)
# perform flip
z_vector <- rev(f_vector)
################################################################## DATA
data <- t(as_tibble(c(z_vector, output[i])))
# Define names of the columns for the data to used by function
ANN_names <- c(paste0("z",(as.character(c(seq(1:nDetect))))),"o")
colnames(data) <- ANN_names
############################################################### FORMULA
f <- as.formula(paste(ANN_names[nDetect+1],
"~",
paste(ANN_names[!ANN_names %in% "o"], collapse = " + ")
)
)
############################################################ NEURAL NET
nn <-neuralnet(f, data, hidden = 2,
startweights = nn$weights,
algorithm = 'backprop',
learningrate = 0.0001)
error[i] <- nn$result.matrix[1]
}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir=normalizePath(".."))
library(neuralnet)
library(tidyverse)
library(binhf)
library(Matrix)
library(ggplot2)
library(pracma)
library(OpenImageR)
# read in reference data
m <- read.csv("raw_data/65ref.csv")
m <- m[, -c(1)]
v <- matrix(nrow = 3, ncol = 0)
# Populate 'v' with columns, rows, and values from 'm'
for (i in 1:nrow(m)){
for (j in 1:ncol(m)){
v <- cbind(v, c(i,j,m[i,j]))
}
}
# Create empty vectors `x`, `z`, and 'output'
x <- vector(length = 0)
z <- vector(length = 0)
output <- vector(length = 0)
# Extract values from each row of `v`
for (i in 1:ncol(v)){
x <- c(x, v[2, i])
z <- c(z, v[1, i])
output <- c(output, v[3, i])
}
x <- (x-(max(x)+1)/2) # make x and z correct for the shift flip sum code
z <- (z-(max(z)+1)/2) # origin referenced coordinates
# read in sinogram data
sino <- read.csv('raw_data/65sin.csv')
sino <- sino[, -c(1)]
# number of projections
nAngle  <- ncol(sino)
# number of detectors
nDetect <- nrow(sino)
# Degrees between projections
angleStep <- 180/(nAngle-1)
# compute angle of each projection in sinogram
degree <- data.frame(angle = seq(0,nAngle-1)*angleStep)
# initialize weights
nn <- list()
nn$weights <- list()
nn$weights[[1]] <- matrix(0, nrow = 16, ncol = 2)
nn$weights[[2]] <- matrix(0, nrow = 3, ncol = 1)
error <- matrix(nrow = 1, ncol = 0)
for (i in 1:length(output)){
# compute shift of sinogram detector positions for each projection based on current image pixel
degree$pixel <- round(x[i]*cos(pi*degree$angle/180) + z[i]*sin(pi*degree$angle/180))
# transpose the sinogram
tsino <- t(sino)
# create a space with dimension tsino
ssino <- tsino
######################################################## SHIFT SUM FLIP
# Perform shift according to dShift
for (j in 1:nAngle){
shift_amount <- degree$pixel[j]
shifted_row <- circshift(tsino[j, ], shift_amount)
ssino[j, ] <- shifted_row
}
# perform summation
f_vector <- colSums(ssino)
# perform flip
z_vector <- rev(f_vector)
################################################################## DATA
data <- t(as_tibble(c(z_vector, output[i])))
# Define names of the columns for the data to used by function
ANN_names <- c(paste0("z",(as.character(c(seq(1:nDetect))))),"o")
colnames(data) <- ANN_names
############################################################### FORMULA
f <- as.formula(paste(ANN_names[nDetect+1],
"~",
paste(ANN_names[!ANN_names %in% "o"], collapse = " + ")
)
)
############################################################ NEURAL NET
nn <-neuralnet(f, data, hidden = 2,
startweights = nn$weights)
error[i] <- nn$result.matrix[1]
}
plot(nn, rep = "best")
# Creating matrices 'm1' which contains the weights from the first layer and 'm2' which contains the
# weights from the second layer
m1 <- nn$weights[[1]][[1]]
m2 <- nn$weights[[1]][[2]]
m1 <- m1 %>% as.data.frame()
m2 <- m2 %>% as.data.frame()
filt_sinoA <- sino
filt_sinoB <- sino
number_cols <- ncol(sino)
for(val in 1:number_cols){
filt_sinoA[,val] <- convolve(sino[,val], m1[2:91,1], type ="circular")
}
filt_sinoA %>%
as.matrix()
write_csv(filt_sinoA, "raw_data/filtsinoa.csv")
for(val in 1:number_cols){
filt_sinoB[,val] <- convolve(sino[,val], m1[2:91,2], type ="circular")
}
#filt_sinoB %>%
as.matrix()
filt_sinoA <- sino
filt_sinoB <- sino
number_cols <- ncol(sino)
for(val in 1:number_cols){
filt_sinoA[,val] <- convolve(sino[,val], m1[2:91,1], type ="circular")
}
filt_sinoA %>%
as.matrix()
write_csv(filt_sinoA, "raw_data/filtsinoa.csv")
for(val in 1:number_cols){
filt_sinoB[,val] <- convolve(sino[,val], m1[2:91,2], type ="circular")
}
filt_sinoB %>%
as.matrix()
write_csv(filt_sinoB, "raw_data/filtsinob.csv")
write_csv(m1, "raw_data/m1.csv")
write_csv(m2, "raw_data/m2.csv")
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir=normalizePath(".."))
library(neuralnet)
library(tidyverse)
library(binhf)
library(Matrix)
library(ggplot2)
library(pracma)
library(OpenImageR)
# read in reference data
m <- read.csv("raw_data/65ref.csv")
m <- m[, -c(1)]
v <- matrix(nrow = 3, ncol = 0)
# Populate 'v' with columns, rows, and values from 'm'
for (i in 1:nrow(m)){
for (j in 1:ncol(m)){
v <- cbind(v, c(i,j,m[i,j]))
}
}
# Create empty vectors `x`, `z`, and 'output'
x <- vector(length = 0)
z <- vector(length = 0)
output <- vector(length = 0)
# Extract values from each row of `v`
for (i in 1:ncol(v)){
x <- c(x, v[2, i])
z <- c(z, v[1, i])
output <- c(output, v[3, i])
}
x <- (x-(max(x)+1)/2) # make x and z correct for the shift flip sum code
z <- (z-(max(z)+1)/2) # origin referenced coordinates
# read in sinogram data
sino <- read.csv('raw_data/65sin.csv')
sino <- sino[, -c(1)]
# number of projections
nAngle  <- ncol(sino)
# number of detectors
nDetect <- nrow(sino)
# Degrees between projections
angleStep <- 180/(nAngle-1)
# compute angle of each projection in sinogram
degree <- data.frame(angle = seq(0,nAngle-1)*angleStep)
# initialize weights
nn <- list()
nn$weights <- list()
nn$weights[[1]] <- matrix(0, nrow = 16, ncol = 2)
nn$weights[[2]] <- matrix(0, nrow = 3, ncol = 1)
error <- matrix(nrow = 1, ncol = 0)
for (i in 1:length(output)){
# compute shift of sinogram detector positions for each projection based on current image pixel
degree$pixel <- round(x[i]*cos(pi*degree$angle/180) + z[i]*sin(pi*degree$angle/180))
# transpose the sinogram
tsino <- t(sino)
# create a space with dimension tsino
ssino <- tsino
######################################################## SHIFT SUM FLIP
# Perform shift according to dShift
for (j in 1:nAngle){
shift_amount <- degree$pixel[j]
shifted_row <- circshift(tsino[j, ], shift_amount)
ssino[j, ] <- shifted_row
}
# perform summation
f_vector <- colSums(ssino)
# perform flip
z_vector <- rev(f_vector)
################################################################## DATA
data <- t(as_tibble(c(z_vector, output[i])))
# Define names of the columns for the data to used by function
ANN_names <- c(paste0("z",(as.character(c(seq(1:nDetect))))),"o")
colnames(data) <- ANN_names
############################################################### FORMULA
f <- as.formula(paste(ANN_names[nDetect+1],
"~",
paste(ANN_names[!ANN_names %in% "o"], collapse = " + ")
)
)
############################################################ NEURAL NET
nn <-neuralnet(f, data, hidden = 2,
startweights = nn$weights)
error[i] <- nn$result.matrix[1]
}
plot(nn, rep = "best")
# Creating matrices 'm1' which contains the weights from the first layer and 'm2' which contains the
# weights from the second layer
m1 <- nn$weights[[1]][[1]]
m2 <- nn$weights[[1]][[2]]
m1 <- m1 %>% as.data.frame()
m2 <- m2 %>% as.data.frame()
filt_sinoA <- sino
filt_sinoB <- sino
number_cols <- ncol(sino)
for(val in 1:number_cols){
filt_sinoA[,val] <- convolve(sino[,val], m1[2:91,1], type ="circular")
}
filt_sinoA %>%
as.matrix()
write_csv(filt_sinoA, "raw_data/filtsinoa.csv")
for(val in 1:number_cols){
filt_sinoB[,val] <- convolve(sino[,val], m1[2:91,2], type ="circular")
}
filt_sinoB %>%
as.matrix()
write_csv(filt_sinoB, "raw_data/filtsinob.csv")
write_csv(m1, "raw_data/m1.csv")
write_csv(m2, "raw_data/m2.csv")
library(PET)
library(png)
#Read in the Sinograms
filt1 <- read.csv("raw_data/filtsinoa.csv")
filt1 <- as.matrix(filt1)
filt1
image(filt1)
filt2 <- read.csv("raw_data/filtsinob.csv")
filt2 <- as.matrix(filt2)
image(filt2)
?iradon
FBP1 <- iradon(filt1, XSamples = 256, YSamples = 256, mode = "BF")
filt1data <- FBP1$irData
image(filt1data)
FBP2 <- iradon(filt2, XSamples = 256, YSamples = 256, mode = "BF")
filt2data <- FBP2$irData
image(filt2data)
# Read in the biases
m1 <- as.matrix(read.csv("raw_data/m1.csv"))
m2 <- as.matrix(read.csv("raw_data/m2.csv"))
b1 <- matrix(m1[1,1], 256, 256)
b2 <- matrix(m1[1,2], 256, 256)
w1 <- m2[2,1]
w2 <- m2[3,1]
bf <- matrix(m2[1,1], 256, 256)
filta <- filt1data - b1
filtb <- filt2data - b2
filtsa <- matrix(nrow = 256, ncol = 256)
for (i in 1:nrow(filta)){
for (j in 1:ncol(filta)){
filtsa[i,j] <- -1/(1+exp(-filta[i,j]))
}
}
image(filtsa)
filtsb <- matrix(nrow = 256, ncol = 256)
for (i in 1:nrow(filtb)){
for (j in 1:ncol(filtb)){
filtsb[i,j] <- -1/(1+exp(-(filtb[i,j])))
}
}
image(filtsb)
filtsa <- filtsa*w1
filtsb <- filtsb*w2
filts <- filtsa + filtsb# + filtsc + filtsd
image(filts)
filts2 <- filts - bf
filts2
image(filts2)
filtf <- matrix(nrow = 256, ncol = 256)
for (i in 1:nrow(filts2)){
for (j in 1:ncol(filts2)){
filtf[i,j] <- -1/(1+exp(-(filts2[i,j])))
}
}
image(filtf)
write.csv(filtf, "clean_data/FBP1.csv")
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir=normalizePath(".."))
library(neuralnet)
library(tidyverse)
library(binhf)
library(Matrix)
library(ggplot2)
library(pracma)
library(OpenImageR)
# read in reference data
m <- read.csv("raw_data/65ref.csv")
m <- m[, -c(1)]
v <- matrix(nrow = 3, ncol = 0)
# Populate 'v' with columns, rows, and values from 'm'
for (i in 1:nrow(m)){
for (j in 1:ncol(m)){
v <- cbind(v, c(i,j,m[i,j]))
}
}
# Create empty vectors `x`, `z`, and 'output'
x <- vector(length = 0)
z <- vector(length = 0)
output <- vector(length = 0)
# Extract values from each row of `v`
for (i in 1:ncol(v)){
x <- c(x, v[2, i])
z <- c(z, v[1, i])
output <- c(output, v[3, i])
}
x <- (x-(max(x)+1)/2) # make x and z correct for the shift flip sum code
z <- (z-(max(z)+1)/2) # origin referenced coordinates
# read in sinogram data
sino <- read.csv('raw_data/65sin.csv')
sino <- sino[, -c(1)]
# number of projections
nAngle  <- ncol(sino)
# number of detectors
nDetect <- nrow(sino)
# Degrees between projections
angleStep <- 180/(nAngle-1)
# compute angle of each projection in sinogram
degree <- data.frame(angle = seq(0,nAngle-1)*angleStep)
# initialize weights
nn <- list()
nn$weights <- list()
nn$weights[[1]] <- matrix(0, nrow = 16, ncol = 2)
nn$weights[[2]] <- matrix(0, nrow = 3, ncol = 1)
error <- matrix(nrow = 1, ncol = 0)
for (i in 1:length(output)){
# compute shift of sinogram detector positions for each projection based on current image pixel
degree$pixel <- round(x[i]*cos(pi*degree$angle/180) + z[i]*sin(pi*degree$angle/180))
# transpose the sinogram
tsino <- t(sino)
# create a space with dimension tsino
ssino <- tsino
######################################################## SHIFT SUM FLIP
# Perform shift according to dShift
for (j in 1:nAngle){
shift_amount <- degree$pixel[j]
shifted_row <- circshift(tsino[j, ], shift_amount)
ssino[j, ] <- shifted_row
}
# perform summation
f_vector <- colSums(ssino)
# perform flip
z_vector <- rev(f_vector)
################################################################## DATA
data <- t(as_tibble(c(z_vector, output[i])))
# Define names of the columns for the data to used by function
ANN_names <- c(paste0("z",(as.character(c(seq(1:nDetect))))),"o")
colnames(data) <- ANN_names
############################################################### FORMULA
f <- as.formula(paste(ANN_names[nDetect+1],
"~",
paste(ANN_names[!ANN_names %in% "o"], collapse = " + ")
)
)
############################################################ NEURAL NET
nn <-neuralnet(f, data, hidden = 2,
startweights = nn$weights)
error[i] <- nn$result.matrix[1]
}
plot(nn, rep = "best")
# Creating matrices 'm1' which contains the weights from the first layer and 'm2' which contains the
# weights from the second layer
m1 <- nn$weights[[1]][[1]]
m2 <- nn$weights[[1]][[2]]
m1 <- m1 %>% as.data.frame()
m2 <- m2 %>% as.data.frame()
filt_sinoA <- sino
filt_sinoB <- sino
number_cols <- ncol(sino)
for(val in 1:number_cols){
filt_sinoA[,val] <- convolve(sino[,val], m1[2:91,1], type ="circular")
}
filt_sinoA %>%
as.matrix()
write_csv(filt_sinoA, "raw_data/filtsinoa.csv")
for(val in 1:number_cols){
filt_sinoB[,val] <- convolve(sino[,val], m1[2:91,2], type ="circular")
}
filt_sinoB %>%
as.matrix()
write_csv(filt_sinoB, "raw_data/filtsinob.csv")
write_csv(m1, "raw_data/m1.csv")
write_csv(m2, "raw_data/m2.csv")
